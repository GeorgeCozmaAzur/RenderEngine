#version 450

#extension GL_GOOGLE_include_directive : enable
#include "common.glsl"

/*#define VOXEL_GRID_SIZE_X 128
#define VOXEL_GRID_SIZE_Y 64
#define VOXEL_GRID_SIZE_Z 128
#define BLUE_NOISE_TEXTURE_SIZE 128
*/
#define COMPUTE_GROUP_SIZE 16
#define COMPUTE_GROUP_SIZE_Z 4
#define EPSILON 0.0001f


layout (local_size_x = COMPUTE_GROUP_SIZE, local_size_y = COMPUTE_GROUP_SIZE, local_size_z = COMPUTE_GROUP_SIZE_Z) in;
layout (binding = 0) uniform sampler2D sampleShadow;
layout (binding = 1) uniform sampler2D sampleShadowColor;
layout (binding = 2) uniform sampler2D s_BlueNoise;
layout (binding = 3) uniform sampler3D s_History;

layout (binding = 4) uniform UBO 
{
	mat4  view;
    mat4  projection;
	mat4  inv_view_proj;
	mat4  prev_view_proj;
	mat4  light_view_proj;
	vec4  camera_position;
	vec4  bias_near_far_pow;
	vec4  light_color;
	float time;
} ubo;

layout (binding = 5, rgba16) uniform image3D resultImage;

/*float exp_01_to_linear_01_depth(float z, float n, float f)
{
    float z_buffer_params_y = f / n;
    float z_buffer_params_x = 1.0f - z_buffer_params_y;

    return 1.0f / (z_buffer_params_x * z + z_buffer_params_y);
}

float linear_01_to_exp_01_depth(float z, float n, float f)
{
    float z_buffer_params_y = f / n;
    float z_buffer_params_x = 1.0f - z_buffer_params_y;

    return (1.0f / z - z_buffer_params_y) / z_buffer_params_x;
}

vec3 id_to_uv(ivec3 id, float n, float f)
{
    // Exponential View-Z
    float view_z = n * pow(f / n, (float(id.z) + 0.5f) / float(VOXEL_GRID_SIZE_Z));

    return vec3((float(id.x) + 0.5f) / float(VOXEL_GRID_SIZE_X),
                (float(id.y) + 0.5f) / float(VOXEL_GRID_SIZE_Y),
                view_z / f);
}

vec3 uv_to_ndc(vec3 uv, float n, float f, float depth_power)
{
    vec3 ndc;
        
    ndc.x = 2.0f * uv.x - 1.0f;
    ndc.y = 2.0f * uv.y - 1.0f;
    ndc.z = 2.0f * linear_01_to_exp_01_depth(uv.z, n, f) - 1.0f;
        
    return ndc;
}
vec3 ndc_to_world(vec3 ndc, mat4 inv_vp)
{
    vec4 p = inv_vp * vec4(ndc, 1.0f);
        
    p.x /= p.w;
    p.y /= p.w;
    p.z /= p.w;
        
    return p.xyz;
}
vec3 id_to_world(ivec3 id, float n, float f, float depth_power, mat4 inv_vp)
{
    vec3 uv = id_to_uv(id, n, f);
    vec3 ndc = uv_to_ndc(uv, n, f, depth_power);
    return ndc_to_world(ndc, inv_vp);
}
vec3 id_to_uv_with_jitter(ivec3 id, float n, float f, float jitter)
{
    // Exponential View-Z
    float view_z = n * pow(f / n, (float(id.z) + 0.5f + jitter) / float(VOXEL_GRID_SIZE_Z));

    return vec3((float(id.x) + 0.5f) / float(VOXEL_GRID_SIZE_X),
                (float(id.y) + 0.5f) / float(VOXEL_GRID_SIZE_Y),
                view_z / f);
}
vec3 id_to_world_with_jitter(ivec3 id, float jitter, float n, float f, float depth_power, mat4 inv_vp)
{
    vec3 uv = id_to_uv_with_jitter(id, n, f, jitter);
    vec3 ndc = uv_to_ndc(uv, n, f, depth_power);
    return ndc_to_world(ndc, inv_vp);
}*/

float sample_blue_noise(ivec3 coord)
{
    ivec2 noise_coord = (coord.xy + ivec2(0, 1) * coord.z * BLUE_NOISE_TEXTURE_SIZE) % BLUE_NOISE_TEXTURE_SIZE;
    return texelFetch(s_BlueNoise, noise_coord, 0).r;
}

/*vec3 world_to_ndc(vec3 world_pos, mat4 vp)
{
    vec4 p = vp * vec4(world_pos, 1.0f);
        
    if (p.w > 0.0f)
    {
        p.x /= p.w;
        p.y /= p.w;
        p.z /= p.w;
    }
    
    return p.xyz;
}
vec3 ndc_to_uv(vec3 ndc, float n, float f, float depth_power)
{
    vec3 uv;
        
    uv.x = ndc.x * 0.5f + 0.5f;
    uv.y = ndc.y * 0.5f + 0.5f;
    uv.z = exp_01_to_linear_01_depth(ndc.z * 0.5f + 0.5f, n, f);

    // Exponential View-Z
    vec2 params = vec2(float(VOXEL_GRID_SIZE_Z) / log2(f / n), -(float(VOXEL_GRID_SIZE_Z) * log2(n) / log2(f / n)));

    float view_z = uv.z * f;
    uv.z = (max(log2(view_z) * params.x + params.y, 0.0f)) / VOXEL_GRID_SIZE_Z;
     
    return uv;
}

vec3 world_to_uv(vec3 world_pos, float n, float f, float depth_power, mat4 vp)
{
    vec3 ndc = world_to_ndc(world_pos, vp);
    return ndc_to_uv(ndc, n, f, depth_power);
}*/

float textureProj(vec4 shadowCoord, vec2 off)
{
	float shadow = 1.0;
	float ambient = 0.0;
	if ( shadowCoord.z > -1.0 && shadowCoord.z < 1.0 ) 
	{
		float dist = texture( sampleShadow, shadowCoord.st + off ).r;
		
		if ( shadowCoord.w > 0.0 && dist < shadowCoord.z ) 
		{
			shadow = ambient;
		}
	}
	return shadow;
}

vec3 textureProjColor(vec4 shadowCoord, vec2 off)
{
	float shadow = 1.0;
	float ambient = 0.0;
	vec3 shadowColor = vec3(1.0);
	if ( shadowCoord.z > -1.0 && shadowCoord.z < 1.0 ) 
	{
		float dist = texture( sampleShadow, shadowCoord.st + off ).r;
		shadowColor = texture( sampleShadowColor, shadowCoord.st + off ).rgb;
		if ( shadowCoord.w > 0.0 && dist < shadowCoord.z ) 
		{
			shadow = ambient;
		}
		shadowColor *= shadow;
	}
	return shadowColor;
}

float sample_shadow_map(vec2 coord, float z)
{
    float current_depth = z;
    float bias = ubo.bias_near_far_pow.x;

    //return texture(inputImage, vec3(coord, current_depth - bias));
    return texture(sampleShadow, coord).r;
}

const mat4 biasMat = mat4( 
	0.5, 0.0, 0.0, 0.0,
	0.0, 0.5, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.5, 0.5, 0.0, 1.0 );
	
float visibility(vec3 p)
{
    // Transform frag position into Light-space.
    vec4 light_space_pos = biasMat * ubo.light_view_proj * vec4(p, 1.0);

    // Perspective divide
    vec4 proj_coords = light_space_pos / light_space_pos.w;

    // Transform to [0,1] range
    //proj_coords = proj_coords * 0.5 + 0.5;

    //if (any(greaterThan(proj_coords.xy, vec2(1.0f))) || any(lessThan(proj_coords.xy, vec2(0.0f))))
    //    return 1.0f;

    //return sample_shadow_map(proj_coords.xy, proj_coords.z);
	return textureProj(proj_coords, vec2(0.0));
}
vec3 visibilityColor(vec3 p)
{
    // Transform frag position into Light-space.
    vec4 light_space_pos = biasMat * ubo.light_view_proj * vec4(p, 1.0);

    // Perspective divide
    vec4 proj_coords = light_space_pos / light_space_pos.w;

    // Transform to [0,1] range
    //proj_coords = proj_coords * 0.5 + 0.5;

    //if (any(greaterThan(proj_coords.xy, vec2(1.0f))) || any(lessThan(proj_coords.xy, vec2(0.0f))))
    //    return 1.0f;

    //return sample_shadow_map(proj_coords.xy, proj_coords.z);
	return textureProjColor(proj_coords, vec2(0.0));
}

void main()
{	
    vec2 xy_float = vec2(float(gl_GlobalInvocationID.x) / 256.0, float(gl_GlobalInvocationID.y) / 256.0);

	/*float r = texture(inputImage, xy_float).x;

	vec3 RGB = vec3(pow(r,10));
	
	vec4 value = vec4(RGB,1.0);*/
	
	ivec3 coord = ivec3(gl_GlobalInvocationID.xyz);
	
	float jitter = (sample_blue_noise(coord) - 0.5f) * 0.999f;
	
	//vec3 world_pos = id_to_world(coord, ubo.bias_near_far_pow.y, ubo.bias_near_far_pow.z, ubo.bias_near_far_pow.w, ubo.inv_view_proj);
	vec3 world_pos = id_to_world_with_jitter(coord, jitter, ubo.bias_near_far_pow.y, ubo.bias_near_far_pow.z, ubo.bias_near_far_pow.w, ubo.inv_view_proj);
	
	vec3 Wo = normalize(ubo.camera_position.xyz - world_pos);

	float density    = 5.0;
	vec3 lighting = vec3(0.1);
	
	//float visibility_value = visibility(world_pos);
	vec3 visibility_value = visibilityColor(world_pos);

    //if (visibility_value > EPSILON)
        lighting += visibility_value;
	vec4 color_and_density = vec4(lighting * density, density);
	
		vec3 world_pos_without_jitter = id_to_world(coord, ubo.bias_near_far_pow.y, ubo.bias_near_far_pow.z, ubo.bias_near_far_pow.w, ubo.inv_view_proj);                

		// Find the history UV
		vec3 history_uv = world_to_uv(world_pos_without_jitter, ubo.bias_near_far_pow.y, ubo.bias_near_far_pow.z, ubo.bias_near_far_pow.w, ubo.prev_view_proj);

		// If history UV is outside the frustum, skip history
		if (all(greaterThanEqual(history_uv, vec3(0.0f))) && all(lessThanEqual(history_uv, vec3(1.0f))))
		{
			// Fetch history sample
			vec4 history = textureLod(s_History, history_uv, 0.0f);

			color_and_density = mix(history, color_and_density, 0.05f);
		}
	
	imageStore(resultImage, coord, color_and_density);
	
	// vec4 testcolor = vec4(id_to_uv(coord, ubo.bias_near_far_pow.y, ubo.bias_near_far_pow.z), 1.0);
	// imageStore(resultImage, coord, testcolor);
	
	// float dist = length(world_pos);
	// float att = 1.0 / (1.0 + 0.1*dist + 0.01*dist*dist) * 10.0;
	// vec4 testcolor = vec4(vec3(att), 1.0);
	// imageStore(resultImage, coord, testcolor);
}
